#!/usr/bin/env sh
## Copyright (c) 2024-2025 by mobinmob  <mobinmob@disroot.org>
## This program is free software: you can redistribute it and/or modify it under
## the terms of the GNU General Public License as published by the Free
## Software Foundation, version 2.0 of the License.
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
## You should have received a copy of the GNU General Public License along with
## this program. If not, see <https://www.gnu.org/licenses/>.
### SPDX short identifier: GPL-2.0-only

# For debug uncomment desired set
#set -u # End if are here unused variables
#set -e # End on first error
#set -x # Show what script is going to do

root_check() {
	# Check for root
	[ "$(id -u)" = 0 ] && usage && msg error "Please run the program as a user!"
}

set_colours() {
# Colours
	if command -v tput >/dev/null 2>&1 && [ -z "${NO_COLOR+x}" ] && [ -t 0 ]; then # make tput(1) optional, respect $NO_COLOR
		green=$(tput setaf 2)
		red=$(tput setaf 1)
		yellow=$(tput setaf 3)
		fade=$(tput dim)
		bold=$(tput bold)
		resetColour=$(tput sgr0)
	else
		green=""
		red=""
		yellow=""
		fade=""
		bold=""
		resetColour=""
	fi
}

set_default_vars() {
# Change version to newer after every update
xutVersion=0.4.1-dev
readonly xutVersion

opLog=0       #Controls the appearance of debug messages for the user (-l)
opQuery=0     #Search for templates (-q)
opBuild=0     #Build packages, ( -b).
opInstall=0   #Install packages (-i <package1,package2>)
opXbpsSrc="" #Contains the xbps-src command to be given after the -x argument
opUpdate=0    #Update sw from updated templates (-u)
opChanged=0   #Indicated that the repo contents have changed, for internal use
opSync=0      #Sync repos
opIntegrate=0 #Intergrate all templates into a merged repo.
opForeignHost=0	#Detection of non-Voidlinux host system.

# Initialise empty vars

templatesToUpdate=""
packageList=""
}

distribution_sanity_check() {
	# Disable install and update when run in a non-Void distribution
	[ -r /etc/os-release ] && . /etc/os-release
	if [ -z "$NAME" ] || [ "$NAME" != "Void" ]; then
		opUpdate=0; opInstall=0; opForeignHost=1
		msg info "[xut] is not running under Void Linux. Install and update operations are disabled."
	else
		msg debug "Running on Void linux, all systems go!"
	fi
}

msg() {
	# Use colour-coded messages for informational, warning, and error output ${1} is the message type,
	# ${2} is the message content needs to be here, all messages depend on it.

	if [ "${1}" = "error" ]; then
		printf "%s\n" "${red}${bold}(!!) Error:${resetColour} ${bold}${2}${resetColour}" ; exit 1
	elif [ "${1}" = "warn" ]; then
		printf "%s\n" "${yellow}${bold}(~~) Warning:${resetColour} ${bold}${2} ${resetColour}"
	elif [ "${1}" = "info" ]; then
		printf "%s\n" "${green}${bold}(~>) Info:${resetColour}  ${bold}${2} ${resetColour}"
	elif [ "${1}" = "debug" ]; then
		[ "$opLog" -eq 1 ] && printf "%s\n" "${fade}(<>) Debug : ${2} ${resetColour}"
	else
		printf "%s\n" "${red}(!!) Error: ${1} is not recognised for msg() ${resetColour}" ; exit 1
	fi
}

set_default_configuration() {
# Get the configuration from the conf file if it exists.

#shellcheck disable=SC1091
if [ -r "$HOME"/xutconf ]; then
	. "$HOME"/xutconf
	msg info "Using configuration from $HOME/xutconf."
elif [ -r "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf ]; then
	. "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf
	msg info "Using configuration from ${XDG_CONFIG_HOME:-$HOME/.config}/xutconf."
else
	msg info "Using the default configuration."
fi

# Setting default configuration

defaultRepo=https://github.com/void-linux/void-packages
readonly defaultRepo
repoAbyssPackages=https://codeberg.org/mobinmob/abyss-packages
readonly repoAbyssPackages
defaultRepoDir=$(rdlast="${defaultRepo%/}"; rdfirst="${rdlast%/*}"; printf '_%s_%s\n' "${rdfirst##*/}" "${rdlast##*/}")
readonly defaultRepoDir
[ -n "$CONF_WORKDIR" ] && confWorkdir="$CONF_WORKDIR" && msg info "Using $confWorkdir as working directory."
[ -z "$confWorkdir" ] && confWorkdir="$HOME"/.xut

# Define a log filename
confLogDir="$confWorkdir/logs"
logFile="$confLogDir/${0##*/}_$(date +"%Y%m%d_%H%M%S").log"

# Check for needed dirs.
[ ! -e "$confLogDir" ] && mkdir -p "$confLogDir"
readonly logFile
XUT_TMP="${XUT_TMPDIR:-/tmp}/xut_tmp" # Use tmpfs for hotspots, adjust if user has XUT_TMPDIR set.
templatesCache="$XUT_TMP/templates"
mkdir -p "$XUT_TMP/templates" || msg error "Cannot create tmpfs workspace $XUT_TMP/templates"
# Merged templates directory
mergedDir=$(mktemp -d "${XUT_TMPDIR:-/tmp}/merged.XXXXXX") || msg error "Cannot create $mergedDir"
# Cleanup on exit
trap 'rm -rf "$mergedDir" "$XUT_TMP/templates"' EXIT INT TERM
}

usage() {
	# Display basic tui information
	cat <<-EOH
		xut $xutVersion
		Usage: ${0##*/} [options]

		*x*tra *u*ser *t*emplates
		Build and install packages for Void Linux, from the abyss-packages unofficial repo

		OPTIONS
		 -s                      Sync the repos.
		 -l                      Keep a log file under $confLogDir.
		 -h                      Display this usage information.
		 -d						 Enable debugging and logging output.
		 -b <package1,package2>  Build a list of (comma-separated) packages.
		 -i <package1,package2>  Build and install a list of (comma-separated) packages.
		 -x                      Give xbps-src commands.
		 -q <query>              Search for <query> in available templates.
		 -u                      Update packages.

		 The options are given together. For example in order to sync,
		 enable logging and install <package> the cli command is
		 <xut -sli package>.

	EOH
}

find_repodir() {
	# Define a proper (no slashes...) directory name for a remote git repo
	repodir=$(rdlast="${1%/}"; rdfirst="${rdlast%/*}"; printf '_%s_%s\n' "${rdfirst##*/}" "${rdlast##*/}")
}

create_template_list() {
	# Creates a newline-separated list of template directory names that exitst under
	# ${1} and stores it in ${2}
	msg debug "Creating template list for ${1} in ${2}..."
    dir="$1"
    out="$2"
    : > "$out"  # empty file

    for d in "$dir"/*; do
        [ -d "$d" ] || continue
        printf "%s\n" "${d##*/}" >> "$out"
    done
}

extract_verrev() {
    awk -F= '
        /version=/ {
            ver=$2
            gsub(/"/,"",ver)
        }
        /revision=/ {
            rev=$2
            gsub(/"/,"",rev)
        }
        ver && rev { print ver "_" rev; exit }
    ' "$1"
}

cmpver() {
    awk -v a="$1" -v b="$2" '
        function norm(s) {
            gsub(/[._-]/, " ", s)
            return s
        }
        BEGIN {
            # Normalize delimiters
            a = norm(a)
            b = norm(b)

            na = split(a, A, " ")
            nb = split(b, B, " ")
            n  = (na > nb ? na : nb)

            for (i = 1; i <= n; i++) {
                xa = (i <= na ? A[i] + 0 : 0)
                xb = (i <= nb ? B[i] + 0 : 0)

                if (xa < xb) exit 255
                if (xa > xb) exit 0
            }

            exit 1   # equal
        }
    '
}

include_additional_repos() {
	# Add all repos to a list, repoAbyssPackages is last
	reposList="$defaultRepo"
	#shellcheck disable=SC2154
	for xtraRepo in $additional_repos; do
		reposList="$reposList $xtraRepo"
	done
	reposList="$reposList $repoAbyssPackages"
}


retrieve_repos() {
	# Clone every configured repo if needed.
	for repo in $reposList; do
		find_repodir "$repo"
		if [ ! -d "$confWorkdir/$repodir"/.git ]; then
			opChanged=1
			msg debug "Cloning $repo..."
			git clone --depth 1 "$repo" "$confWorkdir/$repodir" || msg error "Cannot clone $repo repo."
			msg debug "Successfully cloned $repo !"
			opIntegrate=1
		else
			msg debug "$repo already exists in $repodir !"
		fi
	done
}

sync_repos() {
	# Sync every configured repo.
	msg info "Syncing repos..."
	for repo in $reposList; do
		find_repodir "$repo"
		msg debug "Syncing $repo..."
		currentBranch=$(git -C "$confWorkdir/$repodir" symbolic-ref --short HEAD 2>/dev/null)
		default_branch=$(git -C "$confWorkdir/$repodir" symbolic-ref --short refs/remotes/origin/HEAD | sed 's|origin/||')
		git -C "$confWorkdir/$repodir" checkout "$default_branch" || msg error "Cannot switch to $default_branch. Probably uncommitted changes on $currentBranch?"
		msg debug "Switched to $default_branch"
		git -C "$confWorkdir/$repodir" pull "$repo"  || msg error "Cannot sync to $repo"
		msg info "$repo synced"
	done
	opIntegrate=1
}

should_copy_template() {
	sourceTemplate="$1"
	destTemplate="$2"
	sourceTemplateName="${sourceTemplate%/*}"
	sourceTemplateName="${sourceTemplateName##*/}"
	destTemplateName="${destTemplate%/*}"
	destTemplateName="${destTemplateName##*/}"
	# Quick check - if dest doesn't exist, copy immediately
	if [ ! -f "$destTemplate" ]; then
		msg debug "... $templateName"
		opChanged=1
		return 0
	fi

	# Extract full version_revision strings
	srcVer=$(extract_verrev "$sourceTemplate")
	destVer=$(extract_verrev "$destTemplate")
	msg debug "Comparing: $sourceTemplateName($srcVer) vs $destTemplateName($destVer)"
	cmpver  "$destVer" "$srcVer"
	# If source is newer
	if [ "$?" = 255 ]; then
		msg info "... $templateName ${green}${bold}$srcVer${resetColour}"
		opChanged=1
		return 0
	fi

	return 1
}

merge_xtra_templates() {
	# First remove all templates lists
	if [ "$opLog" -eq 0 ]; then
		rm -f "$templatesCache"/templates_* "$confWorkdir"/*_templates
	else
		rm -v "$templatesCache"/templates_* "$confWorkdir"/*_templates 2>/dev/null
	fi
	# Merge all available template directories to a temporary directory,
	# With intelligent version-based conflict resolution.
	
	for repo in $reposList; do
		find_repodir "$repo"
		repoName="${repo##*/}"
		if [ "$repo" != "$defaultRepo" ]; then
			msg info "Merging templates from ${green}${bold}$repo${resetColour}"
			searchPath="$confWorkdir/$repodir"
			if [ -d "$confWorkdir/$repodir/srcpkgs" ]; then
				searchPath="$confWorkdir/$repodir/srcpkgs"
			fi
			msg debug "Searching in $searchPath"
			# Create xtra repo templates list
			# Show progress during template processing
			create_template_list "$searchPath" "$templatesCache/templates_$repoName"
			processed=0
			# Process templates
			find "$searchPath" -maxdepth 2 -type f -name template | while IFS= read -r template; do
				[ -f "$template" ] || continue
    			dir="${template%/template}"
				processed=$((processed + 1))
				printf "\r%5d " "$processed"
				templateName="${dir##*/}"
				sourceTemplate="$dir/template"
				destTemplate="$confWorkdir/$defaultRepoDir/srcpkgs/$templateName/template"
				if should_copy_template "$sourceTemplate" "$destTemplate"; then
					# Remove from mergedDir if it already exists
					[ -d "$mergedDir/$templateName" ] && rm -rf "${mergedDir:?}/$templateName"
					cp -r "$dir" "$mergedDir" || msg error "Cannot merge templates"
				fi
			done
			printf "\n"
		else
			# create template list for $defaultRepo
			create_template_list "$confWorkdir/$defaultRepoDir/srcpkgs" "$templatesCache"/void_templates
		fi
	done
	# Create template list for restricted packages, in order to include them in update discovery and updates.
	grep -lr "restricted=yes" "$confWorkdir/$defaultRepoDir/srcpkgs/" | awk -F '/' '{print $(NF-1)}' >"$templatesCache/templates_restricted-packages"
}

update_template_list() {
	# Update all templates list
	msg debug "Creating list of templates (This will take a while)"
	[ ! -r "$templatesCache/templates_restricted-packages" ] && merge_xtra_templates # ensure lists exist
	xbps-checkvers -s -D "$confWorkdir/$defaultRepoDir/srcpkgs/" -f %n | sort -u "$templatesCache"/all_templates
	: > "$templatesCache/xtra_templates_source" 
	cat "$templatesCache"/templates_* >>"$templatesCache"/xtra_templates_source
	# Sort/uniq in one step
    sort -u "$templatesCache/xtra_templates_source" > "$templatesCache/xtra_templates"
        # Cleanup
    rm -f "$templatesCache/xtra_templates_source"
    msg debug "Template merge completed."
	msg info "
	templates in void-packages: $(wc -l < "$templatesCache"/void_templates)
	xtra templates: $(wc -l < "$templatesCache"/xtra_templates) (Not unique)
	Available templates: ${green}${bold}$(wc -l < "$templatesCache"/all_templates)${resetColour}
	"
}

integrate_xtra_templates() {
	# Copy merged directory contents to the srcpkgs/ of the void-packages clone.
	merge_xtra_templates
	# Check if mergedDir has any content
	if [ -n "$(ls -A "$mergedDir" 2>/dev/null)" ]; then
		# Remove original directories from void-packages to avoid stale patches
		msg debug "Cleaning older package directories from void-packages"
		for mergedPkg in "$mergedDir"/*; do
			pkgName="${mergedPkg##*/}"
			originalPkg="$confWorkdir/$defaultRepoDir/srcpkgs/$pkgName"
			if [ -d "$originalPkg" ]; then
				msg debug "Removing old package directory: $pkgName"
				rm -rf "$originalPkg" || msg error "Cannot remove $originalPkg"
			fi
		done
		cp -r "$mergedDir"/* "$confWorkdir/$defaultRepoDir/srcpkgs/" || msg error "Cannot copy templates to srcpkgs"
		msg info "Merged templates copied to srcpkgs"
	else
		msg info "No new or updated templates to merge"
	fi
	if [ "$opChanged" = 1 ]; then
		update_template_list
	fi
}

xbps_src_command() {
	# Give xbps-src commands directly to the merged repository.
	cd "$confWorkdir/$defaultRepoDir" || msg error "Cannot change directory into $defaultRepoDir"
	[ -n "$opXbpsSrc" ] || msg error "No xbps-src arguments!"
	./xbps-src "$opXbpsSrc" || msg error "Cannot execute <xbps-src $opXbpsSrc>"
	msg info "[./xbps-src $opXbpsSrc] executed successfully!" && exit 0
}

search_templates() {
	# Update template_list if not exist
	if [ ! -f "$templatesCache"/all_templates ]; then
		update_template_list
	fi

	msg info "Searching for <$templateQuery> ..."
	found=0
	for file in "$templatesCache"/templates_* "$templatesCache"/void_templates; do
		[ ! -f "$file" ] && continue
		if grep -q "$templateQuery" "$file"; then
			found=1
			fileName="${file##*/}"
			case "$fileName" in
				templates_*) fileName=$(echo "$fileName" | cut -d'_' -f2) ;;
				void_templates) fileName="void-packages" ;;
			esac
			msg info "Found in ${green}${bold}$fileName${resetColour}:"
			grep "$templateQuery" "$file" | while read -r line; do
				printf "%s\n" "  ${green}(*)${resetColour} ${bold}${line}${resetColour}"
			done
		fi
	done
	if [ "$found" = 0 ]; then
		msg warn "No templates found!"
	fi
	exit 0
}

discover_updates() {
msg info "Checking for updatable packages..."

# Ensure template list exists
if [ ! -r "$templatesCache/templates_restricted-packages" ]; then
    merge_xtra_templates
fi
# Build list of extra templates
xtraTemplatesFile="$templatesCache/xtra_templates"
: >"$xtraTemplatesFile"
# Append templates safely
for f in "$templatesCache"/templates_*; do
    [ -r "$f" ] && cat "$f" >>"$xtraTemplatesFile"
done
# Normalize list (sorted & unique) - POSIX-safe
tmp1=$(mktemp)
sort -u "$xtraTemplatesFile" >"$tmp1"
mv "$tmp1" "$xtraTemplatesFile"
#Build list of templates to be updated
toBeUpdated="$templatesCache/toBeUpdated"
: >"$toBeUpdated"
xbps-checkvers -I -D "$confWorkdir/$defaultRepoDir/" -f %\n \
    >"$toBeUpdated"
tmp2=$(mktemp)
sort -u "$toBeUpdated" >"$tmp2"
mv "$tmp2" "$toBeUpdated"
# Intersection of sorted lists (comm requires sorting)
comm -12 "$toBeUpdated" "$xtraTemplatesFile" \
    >"$templatesCache/templatesToUpdate"
# Convert file into space-separated list
templatesToUpdate=$(tr '\n' ' ' < "$templatesCache/templatesToUpdate")
export templatesToUpdate
}

update_packages() {
	# Build and install available updates.
	discover_updates
	if [ -n "$templatesToUpdate" ]; then
		msg info "Updating $templatesToUpdate ..."
	else
		msg warn "No updates available"
		exit 0
	fi
	opInstall=1
	packages="$templatesToUpdate"
	install_packages 
	exit 0
}

build_packages() {
	# Prepare for installation
	# Enable building restricted packages
	if grep -q "XBPS_ALLOW_RESTRICTED=yes" "$confWorkdir"/"$defaultRepoDir"/etc/conf; then
		msg debug "Building restricted packages is enabled!"
	else
		msg info "Enable building restricted packages!"
		printf "%s\n" "XBPS_ALLOW_RESTRICTED=yes" >>"$confWorkdir"/"$defaultRepoDir"/etc/conf
	fi
	# Bootstrap if masterdir is not populated
	if [ ! -e "$confWorkdir"/"$defaultRepoDir"/masterdir-"$(xbps-uhelper arch)"/usr/bin/xbps-install ]; then
		cd "$confWorkdir"/"$defaultRepoDir" || msg error "Cannot change to $confWorkdir/$defaultRepoDir"
		./xbps-src binary-bootstrap || msg error "Cannot bootstrap!"
	fi
	# Start package build
	packageList="$(echo "$packages" | tr ',' ' ')"
	export packageList="$packageList"
	# Check if the first package is an argument
	set -- "$packageList"
	for first in i u x h q; do
		if [ "${1}" = $first ]; then
		msg error "${1} is wrong, expecting a package name not an argument!"; fi ;done
	for package in $packageList; do
		cd "$confWorkdir"/"$defaultRepoDir" && ./xbps-src pkg -E "$package"
		cmdStatus=$?
		[ "$cmdStatus" != 0 ] && msg error "$package build failed, see above!"
	done
	# Exit program if build_packages() is called by itself.
	if [ -n "$packages" ] && [ "$opInstall" = 0 ]; then
		msg info "Successfully build $packages!"
		msg info "Packages are in $confWorkdir/$defaultRepoDir/hostdir/."
		[ "$opForeignHost" != 1 ] \
			&& msg info "You can install them with xbps or by running <xut -i>."
		exit 0
	fi
}

install_packages() {
	opBuild=1 && build_packages
	#shellcheck disable=SC2086
	if [ -n "$packages" ] && xi $packageList; then
		msg info " Package(s) $packages installed."
	fi
}

main() {
	msg info "Full command given is [${green}xut $showargs${resetColour}]."
	distribution_sanity_check
	include_additional_repos
	retrieve_repos
	[ "$opSync" -eq 0 ] || sync_repos
	[ "$opIntegrate" -eq 0 ] || integrate_xtra_templates
	[ "$opUpdate" -eq 0 ] || update_packages
	[ "$opQuery" -eq 0 ] || search_templates
	[ "$opBuild" -eq 0 ] || build_packages
	install_packages
}

set_colours
set_default_vars
set_default_configuration
root_check

# Keep at least 5 log files, including the current one.
find "$confLogDir" -name "xut_*.log" -print | sort -r | awk 'NR>5' | xargs rm -f


while getopts "slhudb:i:x:q:" OPTION; do
	case "${OPTION}" in
		s) opSync=1 ;;
		l) opLog=1 ;;
		d) opLog=1; set -x ;;
		b) packages="$OPTARG"; opBuild=1 ;;
		i) packages="$OPTARG"; opInstall=1 ;;
		x) opXbpsSrc="$OPTARG"; xbps_src_command ;;
		q) templateQuery="$OPTARG"; opQuery=1 ;;
		u) opUpdate=1 ;;
		*|h) usage; exit 0 ;;
	esac
done

# Capture all the arguments given
showargs="$(printf "%s" "$*")"
shift $((OPTIND - 1))
[ "$OPTIND" = 1 ] && usage
if [ "$opLog" -eq 1 ]; then
	main 2>&1 | tee -- "$logFile"
else
	main
fi