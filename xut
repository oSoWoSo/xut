#!/usr/bin/env sh
## Copyright (c) 2024-2025 by mobinmob  <mobinmob@disroot.org>
## This program is free software: you can redistribute it and/or modify it under
## the terms of the GNU General Public License as published by the Free
## Software Foundation, version 2.0 of the License.
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
## You should have received a copy of the GNU General Public License along with
## this program. If not, see <https://www.gnu.org/licenses/>.
### SPDX short identifier: GPL-2.0-only

# For debug uncomment desired set
#set -u # End if are here unused variables
#set -e # End on first error
#set -x # Show what script is going to do

# Change version to newer after every update
readonly xutVersion=0.4.1-dev

root_check() {
	# Check for root
	[ "$(id -u)" = 0 ] && usage && msg error "Please run the program as a user!"
}

set_colours() {
# Colours
	if command -v tput >/dev/null 2>&1 && [ -z "${NO_COLOR+x}" ] && [ -t 0 ]; then # make tput(1) optional, respect $NO_COLOR
		green=$(tput setaf 2)
		red=$(tput setaf 1)
		yellow=$(tput setaf 3)
		fade=$(tput dim)
		bold=$(tput bold)
		resetColour=$(tput sgr0)
	else
		green=""
		red=""
		yellow=""
		fade=""
		bold=""
		resetColour=""
	fi
}

set_default_vars() {
opLog=0       #Controls the appearance of debug messages for the user (-l)
opQuery=0     #Search for templates (-q)
opBuild=0     #Build packages, ( -b).
opInstall=0   #Install packages (-i <package1,package2>)
opXbpsSrc="" #Contains the xbps-src command to be given after the -x argument
opUpdate=0    #Update sw from updated templates (-u)
opChanged=0   #Indicated that the repo contents have changed, for internal use
opRetrieve=0  #Clone repos repos (-s)
opSync=0      #Sync repos
opIntegrate=0 #Intergrate all templates into a merged repo.
opForeignHost=0	#Detection of non-Voidlinux host system.
}

distribution_sanity_check() {
	# Disable install and update when run in a non-Void distribution
	[ -r /etc/os-release ] && . /etc/os-release
	if [ -z "$NAME" ] || [ "$NAME" != "Void" ]; then
		opUpdate=0
		opInstall=0
		opForeignHost=1
		msg info "[xut] is not running under Void Linux. Install and update operations are disabled."
	else
		msg debug "Running on Void linux, all systems go!"
	fi
}


msg() {
	# Use colour-coded messages for informational, warning, and error output ${1} is the message type,
	# ${2} is the message content needs to be here, all messages depend on it.

	if [ "${1}" = "error" ]; then
		printf "%s\n" "${red}${bold}(!!) Error:${resetColour} ${bold}${2}${resetColour}" && exit 1
	elif [ "${1}" = "warn" ]; then
		printf "%s\n" "${yellow}${bold}(~~) Warning:${resetColour} ${bold}${2} ${resetColour}"
	elif [ "${1}" = "info" ]; then
		printf "%s\n" "${green}${bold}(~>) Info:${resetColour}  ${bold}${2} ${resetColour}"
	elif [ "${1}" = "debug" ]; then
		[ "$opLog" = 1 ] && printf "%s\n" "${fade}(<>) Debug : ${2} ${resetColour}"
	else
		printf "%s\n" "${red}(!!) Error: ${1} is not recognised for msg() ${resetColour}" && exit 1
	fi
}

set_default_configuration() {
# Get the configuration from the conf file if it exists.

#shellcheck disable=SC1091
if [ -r "$HOME"/xutconf ]; then
	. "$HOME"/xutconf
	msg info "Using configuration from $HOME/xutconf."
elif [ -r "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf ]; then
	. "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf
	msg info "Using configuration from ${XDG_CONFIG_HOME:-$HOME/.config}/xutconf."
else
	msg info "Using the default configuration."
fi

# Setting default configuration

readonly defaultRepo=https://github.com/void-linux/void-packages
readonly repoAbyssPackages=https://codeberg.org/mobinmob/abyss-packages
defaultRepoDir=$(printf '%s' "$defaultRepo" | awk -F"/" '{ print "/"$(NF-1)"/"$NF }' | tr "/" "_")
readonly defaultRepoDir
[ -n "$CONF_WORKDIR" ] && confWorkdir="$CONF_WORKDIR" && msg info "Using $confWorkdir as working directory."
[ -z "$confWorkdir" ] && confWorkdir="$HOME"/.xut

# Define a log filename
confLogDir="$confWorkdir/logs"
logFile="$confLogDir/$(basename "$0")_$(date +"%Y%m%d_%H%M%S").log"

# Check for needed dirs.
[ ! -e "$confLogDir" ] && mkdir -p "$confLogDir"
readonly logFile
mergedDir=$(mktemp -d "${TMPDIR:-/tmp}/xutXXXX.merged")
trap 'rm -rf "$mergedDir"' EXIT INT TERM
}

usage() {
	# Display basic tui information
	cat <<-EOH
		xut $xutVersion
		Usage: $(basename "$0") [options]

		*x*tra *u*ser *t*emplates
		Build and install packages for Void Linux, from the abyss-packages unofficial repo

		OPTIONS
		 -s                      Sync the repos.
		 -l                      Keep a log file under $confLogDir.
		 -h                      Display this usage information.
		 -b <package1,package2>  Build a list of (comma-separated) packages.
		 -i <package1,package2>  Build and install a list of (comma-seperated) packages.
		 -x                      Give xbps-src commands.
		 -q <query>              Search for <query> in available templates.
		 -u                      Update packages.

		 The options are given together. For example in order to sync,
		 enable logging and install <package> the cli command is
		 <xut -sli package>.

	EOH
}

find_repodir() {
	# Define a proper (no slashes...) directory name for a remote git repo
	repodir=$(printf '%s' "${1}" | awk -F"/" '{ print "/"$(NF-1)"/"$NF }' | tr "/" "_")
}

create_template_list() {
	# Creates a newline-seperated list of template directory names that exitst under
	# ${2} and stores it in ${2}
   find -L "${1}" -mindepth 1 -maxdepth 1 -type d | sed 's:/*$::' | sed 's:.*/::' > "$2"
}

extract_verrev() {
 # Extract version and revision information from template ${2}.
awk -F= '
	/^version=/ { gsub(/"/, "", $2); ver=$2 }
	/^revision=/ { gsub(/"/, "", $2); rev=$2 }
	 END { printf "%s_%s", ver, rev }
	' "$1"
}

include_additional_repos() {
	# Add all repos to a list, repoAbyssPackages is last
	reposList="$defaultRepo"
	#shellcheck disable=SC2154
	for xtraRepo in $additional_repos; do
		reposList="$reposList $xtraRepo"
	done
	reposList="$reposList $repoAbyssPackages"
}


retrieve_repos() {
	# Clone every configured repo if needed.
	for repo in $reposList; do
		find_repodir "$repo"
		if [ ! -d "$confWorkdir"/"$repodir" ]; then
			opChanged=1
			msg debug "Cloning $repo..."
			git clone --depth 1 "$repo" "$confWorkdir"/"$repodir" || msg error "Cannot clone $repo repo."
			msg debug "Successfully cloned $repo !"
		else
			msg debug "$repo already exists in $repodir !"
		fi
	done

	# Remove all non-upstream repo from the void-packages clone to start from scratch
	cd "$confWorkdir"/"$defaultRepoDir" && git checkout .
	opSync=1
}

sync_repos() {
	# Sync every configured repo.
	if [ "$opSync" = 0 ]; then
		msg debug "Syncing repos not requested"
		return
	fi
	msg info "Syncing repos..."
	for repo in $reposList; do
		find_repodir "$repo"
		msg debug "Syncing $repo..."
		cd "$confWorkdir"/"$repodir" || msg error "Cannot change to $confWorkdir/$repodir"
		currentBranch=$(git branch --show-current 2>/dev/null)
		default_branch=$(git remote show origin | awk '/HEAD branch/ {print $NF}')
		git checkout "$default_branch" || msg error "Cannot switch to $default_branch. Probably uncommitted changes on $currentBranch?"
		msg debug "Switched to $default_branch"
		git pull "$repo" || msg error "Cannot sync to $repo"
		msg info "$repo synced"
	done
	opIntegrate=1
}

should_copy_template() {
	sourceTemplate="$1"
	destTemplate="$2"
	sourceTemplateName=$(echo "$sourceTemplate" | awk -F '/' '{print $(NF-1)}')
	destTemplateName=$(echo "$destTemplate" | awk -F '/' '{print $(NF-1)}')
	# Quick check - if dest doesn't exist, copy immediately
	if [ ! -f "$destTemplate" ]; then
		msg info "... $templateName"
		opChanged=1
		return 0
	fi

	# Extract full version_revision strings
	srcVer=$(extract_verrev "$sourceTemplate")
	destVer=$(extract_verrev "$destTemplate")
	msg debug "Comparing: $sourceTemplateName($srcVer) vs $destTemplateName($destVer)"
	xbps-uhelper cmpver "$destVer" "$srcVer"
	# If source is newer
	if [ "$?" = 255 ]; then
		msg info "... $templateName ${green}${bold}$srcVer${resetColour}"
		opChanged=1
		return 0
	fi

	return 1
}

merge_xtra_templates() {
	# First remove all templates lists
	if [ "$opLog" = 0 ]; then
		rm -f "$confWorkdir"/templates_*
		rm -f "$confWorkdir"/*_templates
	else
		rm -v "$confWorkdir"/templates_* 2>/dev/null
		rm -v "$confWorkdir"/*_templates 2>/dev/null
	fi
	# Merge all available template directories to a temporary directory,
	# With intelligent version-based conflict resolution.
	for repo in $reposList; do
		find_repodir "$repo"
		if [ "$repo" != "$defaultRepo" ]; then
			msg info "Merging templates from ${green}${bold}$repo${resetColour}"
			searchPath="$confWorkdir/$repodir"
			if [ -d "$confWorkdir/$repodir/srcpkgs" ]; then
				searchPath="$confWorkdir/$repodir/srcpkgs"
			fi
			msg debug "Searching in $searchPath"
			# Create xtra repo templates list
			repoName=$(basename "$repo")
			# Include both directories and symlinks
			# Show progress during template processing
			create_template_list "$searchPath" "$confWorkdir/templates_$repoName"
			processed=0
			# Process templates
			for dir in "$searchPath"/*; do
				[ ! -d "$dir" ] && [ ! -L "$dir" ] && continue
				[ ! -e "$dir/template" ] && continue
				processed=$((processed + 1))
				printf "\r%5d " "$processed"
				templateName=$(basename "$dir")
				sourceTemplate="$dir/template"
				destTemplate="$confWorkdir/$defaultRepoDir/srcpkgs/$templateName/template"
				if should_copy_template "$sourceTemplate" "$destTemplate"; then
					# Remove from mergedDir if it already exists
					[ -d "$mergedDir/$templateName" ] && rm -rf "${mergedDir:?}/$templateName"
					cp -r "$dir" "$mergedDir" || msg error "Cannot merge templates"
				fi
			done
			printf "\n"
		else
			# Include both directories and symlinks for void_templates
			create_template_list "$confWorkdir/$defaultRepoDir/srcpkgs" "$confWorkdir"/void_templates
		fi
	done
	# Create template list for restricted packages, in order to include them in update discovery and updates.
	grep -lr "restricted=yes" "$confWorkdir/$defaultRepoDir/srcpkgs/" | awk -F '/' '{print $(NF-1)}' >"$confWorkdir/templates_restricted-packages"
}

update_template_list() {
	# Update all templates list
	msg debug "Creating list of templates (This will take a while)"
	create_template_list "$confWorkdir/$defaultRepoDir/srcpkgs/" "$confWorkdir"/all_templates_source
	for list in "$confWorkdir"/templates_*; do
		cat "$list" >>"$confWorkdir"/xtraTemplates_source
	done
	# Uniq and sort template lists
	cat "$confWorkdir"/xtraTemplates_source | sort -u >"$confWorkdir"/xtraTemplates
	rm -f "$confWorkdir"/xtraTemplates_source
	cat "$confWorkdir"/all_templates_source | sort -u >"$confWorkdir"/all_templates
	rm -f "$confWorkdir"/all_templates_source
	msg debug "Template merge completed."
	msg info "
	templates in void-packages: $(cat "$confWorkdir"/void_templates | wc -w)
	xtraTemplates: $(cat "$confWorkdir"/xtraTemplates | wc -w) (Not unique)
	Available templates: ${green}${bold}$(cat "$confWorkdir"/all_templates | wc -w)${resetColour}
	"
}

integrate_xtra_templates() {
	# Copy merged directory contents to the srcpkgs/ of the void-packages clone.
	if [ "$opIntegrate" = 0 ]; then
		msg debug "Integration of xtra templates not requested"
		return
	fi
		merge_xtra_templates
	# Check if mergedDir has any content
	if [ -n "$(ls -A "$mergedDir" 2>/dev/null)" ]; then
		# Remove original directories from void-packages to avoid stale patches
		msg debug "Cleaning older package directories from void-packages"
		for merged_pkg in "$mergedDir"/*; do
			pkgName=$(basename "$merged_pkg")
			originalPkg="$confWorkdir/$defaultRepoDir/srcpkgs/$pkgName"
			if [ -d "$originalPkg" ]; then
				msg debug "Removing old package directory: $pkgName"
				rm -rf "$originalPkg" || msg error "Cannot remove $originalPkg"
			fi
		done
		cp -r "$mergedDir"/* "$confWorkdir/$defaultRepoDir/srcpkgs/" || msg error "Cannot copy templates to srcpkgs"
		msg info "Merged templates copied to srcpkgs"
	else
		msg info "No new or updated templates to merge"
	fi
	if [ "$opChanged" = 1 ]; then
		update_template_list
	fi
}

xbps_src_command() {
	# Give xbps-src commands directly to the merged repository.
	cd "$confWorkdir"/"$defaultRepoDir" || msg error "Cannot change directory into $defaultRepoDir"
	./xbps-src clean || msg error "Cannot execute <xbps-src clean>."
	./xbps-src "$opXbpsSrc" || msg error "Cannot execute <xbps-src $opXbpsSrc>"
	msg info "[./xbps-src $opXbpsSrc] executed successfully!" && exit 0
}

search_templates() {
	# Search available templates.
	if [ "$opQuery" = 0 ]; then
		msg debug "No template search requested.."
		return
	fi

	# Update template_list if not exist
	if [ ! -f "$confWorkdir"/all_templates ]; then
		update_template_list
	fi

	msg info "Searching for <$templateQuery> ..."
	found=0
	for file in "$confWorkdir"/templates_* "$confWorkdir"/void_templates; do
		[ ! -f "$file" ] && continue
		if grep -q "$templateQuery" "$file"; then
			found=1
			fileName=$(basename "$file")
			case "$fileName" in
				templates_*) fileName=$(echo "$fileName" | cut -d'_' -f2) ;;
				void_templates) fileName="void-packages" ;;
			esac
			msg info "Found in ${green}${bold}$fileName${resetColour}:"
			grep "$templateQuery" "$file" | while read -r line; do
				printf "%s\n" "  ${green}(*)${resetColour} ${bold}${line}${resetColour}"
			done
		fi
	done
	if [ "$found" = 0 ]; then
		msg warn "No templates found!"
	fi
	exit 0
}

discover_updates() {
	# Compare versions of available templates to these of installed
	# packages and create a list of packages to update.
	msg info "Checking for updatable packages..."
	for list in "$confWorkdir"/templates_*; do
		cat "$list" >>"$confWorkdir"/xtraTemplates
	done
	xtraTemplates="$(cat "$confWorkdir"/xtraTemplates | tr "\n" " ")"
	for template in $xtraTemplates; do
		msg debug "Checking $template"
		if xbps-query -p pkgname "$template" >/dev/null; then
			templatesToCheck="$templatesToCheck $template"
		fi
	done
	for template in $templatesToCheck; do
		msg debug "Comparing versions of $template"
		templateVersion=$(extract_verrev "$confWorkdir/$defaultRepoDir/srcpkgs/$template"/template)
		installedVersion=$(xbps-query -p pkgver "$template" | sed "s/$template-//g")
		xbps-uhelper cmpver "$installedVersion" "$templateVersion"
		[ "$?" = 255 ] && templatesToUpdate="$templatesToUpdate $template"
	done
}

update_packages() {
	# Build and install available updates.
	if [ "$opUpdate" = 0 ]; then 
		msg debug "No update requested"
		return; fi
	discover_updates
	if [ -n "$templatesToUpdate" ]; then
		msg info "Updating $templatesToUpdate ..."
	else
		msg warn "No updates available"
		exit 0
	fi
	opInstall=1
	packages="$templatesToUpdate"
	install_packages
}

build_packages() {
	if [ "$opBuild" = 0 ]; then
		msg debug "No package build requested" 
		return; fi
	# Prepare for installation

	# Enable building restricted packages
	if grep -q "XBPS_ALLOW_RESTRICTED=yes" "$confWorkdir"/"$defaultRepoDir"/etc/conf; then
		msg debug "Building restricted packages is enabled!"
	else
		msg info "Enable building restricted packages!"
		printf "%s\n" "XBPS_ALLOW_RESTRICTED=yes" >>"$confWorkdir"/"$defaultRepoDir"/etc/conf
	fi

	# Bootstrap if masterdir is not populated
	if [ ! -e "$confWorkdir"/"$defaultRepoDir"/masterdir-"$(xbps-uhelper arch)"/usr/bin/xbps-install ]; then
		cd "$confWorkdir"/"$defaultRepoDir" || msg error "Cannot change to $confWorkdir"/"$defaultRepoDir"
		./xbps-src binary-bootstrap || msg error "Cannot bootstrap!"
	fi

	# Start package build
	packageList="$(echo "$packages" | tr ',' ' ')"
	export packageList="$packageList"
	for package in $packageList; do
		cd "$confWorkdir"/"$defaultRepoDir" && ./xbps-src pkg -E "$package"
		cmdStatus=$?
		[ "$cmdStatus" != 0 ] && msg error "$package build failed, see above!"
	done

	# Exit program if build_packages() is called by itself.
	if [ -n "$packages" ] && [ "$opInstall" = 0 ]; then
		msg info "Successfully build $packages!"
		msg info "Packages are in $confWorkdir/$defaultRepoDir/hostdir/."
		[ "$opForeignHost" != 1 ] \
			&& msg info "You can install them with xbps or by running <xut -i>."
		exit 0
	fi
}

install_packages() {
	if [ "$opInstall" = 0 ]; then 
		msg debug "No package installation requested"
		return ; fi
	opBuild=1 && build_packages
	#shellcheck disable=SC2086
	if [ -n "$packages" ] && xi $packageList; then
		msg info " Package(s) $packages installed."
	fi
}

main() {
	msg info "Full command given is [${green}xut $showargs${resetColour}]."
	distribution_sanity_check
	[ -n "$opXbpsSrc" ] && xbps_src_command
	include_additional_repos

	# Clone repos if needed
	retrieve_repos
	sync_repos
	integrate_xtra_templates
	update_packages
	search_templates
	build_packages
	install_packages
}

set_colours
root_check
set_default_vars
set_default_configuration


# Keep at least 5 log files, including the current one.
find "$confLogDir" -name "xut_*.log" -print | sort -r | awk 'NR>5' | xargs rm -f




while getopts "slhub:i:x:q:" OPTION; do
	case "${OPTION}" in
		s) opRetrieve=1 ;;
		l) opLog=1 ;;
		h)	
			usage
			exit 0
			;;
		b) packages="$OPTARG" && opBuild=1 ;;
		i) packages="$OPTARG" && opInstall=1 ;;
		x) opXbpsSrc="$OPTARG" ;;
		q) templateQuery="$OPTARG" && opQuery=1 ;;
		u) opUpdate=1 ;;
		*)
			usage
			exit 0
			;;
	esac
done

# Capture all the arguments given
showargs="$(printf "%s" "$*")"
shift $((OPTIND - 1))
[ "$OPTIND" = 1 ] && usage && root_check && exit
if [ "$opLog" = 1 ]; then
	main 2>&1 | tee -- "$logFile"
else
	main
fi
