#!/usr/bin/env sh
## Copyright (c) 2024-2025 by mobinmob  <mobinmob@disroot.org
## This program is free software: you can redistribute it and/or modify it under
## the terms of the GNU General Public License as published by the Free
## Software Foundation, version 2.0 of the License.
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
## You should have received a copy of the GNU General Public License along with
## this program. If not, see <https://www.gnu.org/licenses/>.
### SPDX short identifier: GPL-2.0-only

# For debug uncomment desired set
#set -u # End if are here unused variables
#set -e # End on first error
#set -x # Show what script is going to do

msg() {
	# Use colour-coded messages for informational, warning, and error output ${1} is the message type,
	# ${2} is the message content needs to be here, all messages depend on it.

	# Colours
	red=$(tput setaf 1)
	green=$(tput setaf 2)
	yellow=$(tput setaf 3)
	blue=$(tput setaf 4)
	pink=$(tput setaf 5)
	gray=$(tput setaf 8)
	fade=$(tput dim)
	bold=$(tput bold)
	R=$(tput sgr0)

	case "${1}" in
		debug) [ "$op_log" = 1 ] && printf "%s\n" "$fade(<>) Debug : ${2} ${R}" ;;
		error) printf "%s\n" "${red}${bold}(!!) Error:${R} ${bold}${2}${R}" && exit 1 ;;
		 warn) printf "%s\n" "${yellow}${bold}(~~) Warning:${R} ${bold}${2} ${R}" ;;
		 info) printf "%s\n" "${green}${bold}(~>) Info:${R}  ${bold}${2} ${R}" ;;
		    *) printf "%s\n" "${red}(!!) Error: ${1} is not recognised for msg() ${R}" && exit 1 ;;
	esac
}

# Get the configuration from the conf file if it exists.
#shellcheck disable=SC1091
if [ -e "$HOME"/xutconf ]; then
	. "$HOME"/xutconf
	msg info "Using configuration from $HOME/xutconf."
elif [ -e "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf ]; then
	. "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf
	msg info "Using configuration from ${XDG_CONFIG_HOME:-$HOME/.config}/xutconf."
else
	msg info "Using the default configuration."
fi

# Setting default configuration
readonly default_repo=https://github.com/void-linux/void-packages
readonly repo_abyss_packages=https://codeberg.org/mobinmob/abyss-packages
default_repo_dir=$(printf '%s' "$default_repo" | awk -F"/" '{ print "/"$(NF-1)"/"$NF }' | tr "/" "_")
readonly default_repo_dir
readonly merge_branch=xut
[ -z "$conf_workdir" ] && conf_workdir="$HOME"/.xut

# Define a log filename
conf_log_dir="$conf_workdir/logs"
log_file="$conf_log_dir/$(basename "$0")_$(date +"%Y%m%d_%T")".log

# Check for needed dirs.
[ ! -e "$conf_log_dir" ] && mkdir -p "$conf_log_dir"
readonly log_file
merged_dir=$(mktemp -d xutTMP.XXX)
#merged_dir=$(mktemp -d xut-mergedXXX)

# Set default operation variables
op_xbps_src=""
op_log=0
op_sync=0
op_query=0
op_build=0
op_update=0
op_changed=0
op_install=0
op_retrieve=0
op_integrate=0

usage() {
	# Display basic tui information
	cat <<-EOH
		Usage: $(basename "$0") [options]

		*x*tra *u*ser *t*emplates
		Build and install packages for Void Linux
		From the abyss-packages unofficial repo and another custom repositories

		OPTIONS
		 -s                      Sync the repos.
		 -l                      Keep a log file under $conf_log_dir. (DEBUG)
		 -b <package1,package2>  Build a list of (comma-separated) packages.
		 -i <package1,package2>  Build and install a list of (comma-seperated) packages.
		 -x                      Give xbps-src commands.
		 -q <query>              Search for <query> in available templates.
		 -u                      Update packages.
		 -h                      Display this usage information.

		 The options are given together. For example in order to sync,
		 enable logging and install <package> the cli command is
		 <xut -sli package>.

	EOH
}

show_progress() {
	# Show a spinner to indicate the script is working
	# Usage: long_running_command & show_progress $!
	pid=$1
	i=0
	# Define colors
	white=$(tput setaf 7)
	while kill -0 "$pid" 2>/dev/null; do
		case $i in
			0) char='|'; color="$yellow" ;;
			1) char='/'; color="$green" ;;
			2) char='-'; color="$white" ;;
			3) char='\'; color="$red" ;;
		esac
		printf "\r${color}%s${reset_colour} " "$char"
		i=$(( (i+1) %4 ))
		sleep 0.1
	done
	printf "\r"
}

show_progress_UTF8() {
	# Show a spinner to indicate the script is working
	# Usage: long_running_command & show_progress $!
	pid=$1
	spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
	i=0

	while kill -0 "$pid" 2>/dev/null; do
		# Extract character using cut instead of substring
		char=$(printf "%s" "$spin" | cut -c$((i+1)))
		printf "\r${green}%s${reset_colour} " "$char"
		i=$(( (i+1) %10 ))
		sleep 0.1
	done
	printf "\r"
}

find_repodir() {
	# Define a proper (no slashes...) directory name for a remote git repo
	repodir=$(printf '%s' "${1}" | awk -F"/" '{ print "/"$(NF-1)"/"$NF }' | tr "/" "_")
}

get_version() {
	# Get the version from the template file given as ${1}
	version=$(grep -E "^(version)[=]" "${1}" \
		| sed -E 's/^(version)[=][[:space:]]*["]?([0-9.]+)["]?.*/\2/')
	export version="$version"
}

get_revision() {
	# Get the revision from the template file given as ${1}
	revision=$(grep -E "^(revision)[=]" "${1}" \
		| sed -E 's/^(revision)[=][[:space:]]*["]?([0-9]+)["]?.*/\2/')
	export revision="$revision"
}

include_additional_repos() {
	# Add all repos to a list, repo_abyss_package is last and its contents superseed the others.
	repos_list="$default_repo"
	#shellcheck disable=SC2154
	for xtra_repo in $additional_repos; do
		repos_list="$repos_list $xtra_repo"
	done
	repos_list="$repos_list $repo_abyss_packages"
}

have_branch() {
	if [ "${repo}" != "${repo%@*}" ]; then
		branch=$(echo "$repo" | cut -d'@' -f2)
		msg debug "Using custom $branch branch"
		repo=$(echo "$repo" | cut -d'@' -f1)
		havebranch=yes
	else
		havebranch=no
		msg debug "Using standard branch"
	fi
}

retrieve_repos() {
	if [ "$op_retrieve" = 0 ]; then
		msg debug "Not retrieving repos..."
		return
	fi
	# Clone every configured repo if needed.
	for repo in $repos_list; do
		have_branch
		find_repodir "$repo"
		if [ ! -d "$conf_workdir"/"$repodir" ]; then
			op_changed=1
			if [ "$havebranch" = 'no' ]; then
				if [ "$clone_history" = 'full' ]; then
					msg info "Cloning $repo with full history..."
					git clone "$repo" "$conf_workdir"/"$repodir" || msg error "Cannot clone $repo repo."
				else
					msg info "Cloning $repo..."
					git clone --depth 1 --no-single-branch "$repo" "$conf_workdir"/"$repodir" || msg error "Cannot clone $repo repo."
				fi
			elif [ "$havebranch" = 'yes' ]; then
				if [ "$clone_history" = 'full' ]; then
					msg info "Cloning $repo branch ${green}${branch}${R} with full history..."
					git clone -b "$branch" "$repo" "$conf_workdir"/"$repodir" || msg error "Cannot clone $repo repo."
				else
					msg info "Cloning $repo branch ${green}${branch}${R}..."
					git clone --depth 1 --no-single-branch -b "$branch" "$repo" "$conf_workdir"/"$repodir" || msg error "Cannot clone $repo repo."
				fi
			else
				msg error "Variable 'havebranch' badly defined !"
				exit 1
			fi
			msg debug "Successfully cloned $repo !"
			msg info "Creating templates list"
			create_template_list_for_repo
		else
			msg debug "$repo already exists in $repodir !"
		fi
	done

	# Remove all not commited changes from the void-package clone
	cd "$conf_workdir"/"$default_repo_dir" && git checkout .
	op_sync=1
}

sync_repos() {
	# Sync every configured repo.
	if [ "$op_sync" = 0 ]; then
		msg debug "Not syncing repos..."
		return
	fi
	for repo in $repos_list; do
		have_branch
		find_repodir "$repo"
		msg info "Syncing $repo..."
		cd "$conf_workdir"/"$repodir" || msg error "Cannot change to $conf_workdir/$repodir"
		current_branch=$(git branch --show-current 2>/dev/null)
		if [ "$repo" = "$default_repo" ] && [ "$current_branch" != "master" ]; then
			git checkout master || msg error "Cannot switch to master branch. Probably uncommitted changes on $current_branch?"
			msg debug "Switched to master branch"
		fi
		if [ "$havebranch" = 'yes' ] ; then
			git pull origin || msg error "Cannot sync to $repo"
			msg info "Branch $branch from $repo synced"
			echo
		else
			git pull origin || msg error "Cannot sync to $repo"
			msg info "$repo synced"
			echo
		fi
	done
	op_integrate=1
}

should_copy_template() {
	source_template="$1"
	dest_template="$2"
	# Quick check - if dest doesn't exist, copy immediately
	if [ ! -f "$dest_template" ]; then
		msg debug "Merging $template_name"
		op_changed=1
		return 0
	fi

	# Extract version and revision in one grep pass for each file
	src_data=$(grep -E "^(version|revision)=" "$source_template" 2>/dev/null)
	dest_data=$(grep -E "^(version|revision)=" "$dest_template" 2>/dev/null)

	# Parse source
	src_version=$(echo "$src_data" | grep "^version=" | head -1 | sed -E 's/^version=["'\''[:space:]]*([0-9.]+).*/\1/')
	src_revision=$(echo "$src_data" | grep "^revision=" | head -1 | sed -E 's/^revision=["'\''[:space:]]*([0-9]+).*/\1/')

	# Parse dest
	dest_version=$(echo "$dest_data" | grep "^version=" | head -1 | sed -E 's/^version=["'\''[:space:]]*([0-9.]+).*/\1/')
	dest_revision=$(echo "$dest_data" | grep "^revision=" | head -1 | sed -E 's/^revision=["'\''[:space:]]*([0-9]+).*/\1/')

	# Quick comparison without multiple sed calls
	src_v=$(echo "$src_version" | tr -d '.')
	dest_v=$(echo "$dest_version" | tr -d '.')

	msg debug "Comparing: src(${src_version}_${src_revision}) vs dest(${dest_version}_${dest_revision})"

	# Compare versions
	if [ "$src_v" -gt "$dest_v" ] 2>/dev/null; then
		msg info "Merging newer ${green}${bold}$template_name${reset_colour} version"
		op_changed=1
		return 0
	elif [ "$src_v" -lt "$dest_v" ] 2>/dev/null; then
		return 1
	fi

	# Versions equal, compare revision
	if [ "$src_revision" -gt "$dest_revision" ] 2>/dev/null; then
		msg info "Merging newer ${green}${bold}$template_name${reset_colour} revision"
		op_changed=1
		return 0
	fi

	return 1
}

merge_shlibs() {
	# Merge common/shlibs from all repos
	# Extra repos override void-packages entries
	msg info "Merging common/shlibs files..."

	shlibs_temp="$(mktemp)"
	shlibs_final="$conf_workdir/$default_repo_dir/common/shlibs"

	# Start with void-packages shlibs as base
	if [ -f "$shlibs_final" ]; then
		cp "$shlibs_final" "$shlibs_temp" || msg error "Cannot copy base shlibs file"
		msg debug "Copied base shlibs from void-packages"
	else
		msg error "No shlibs file found in void-packages"
		touch "$shlibs_temp"
	fi

	# Process each extra repo
	for repo in $repos_list; do
		find_repodir "$repo"

		# Skip void-packages (already processed)
		[ "$repo" = "$default_repo" ] && continue

		repo_shlibs=""
		# Check both possible locations
		if [ -f "$conf_workdir/$repodir/common/shlibs" ]; then
			repo_shlibs="$conf_workdir/$repodir/common/shlibs"
		elif [ -f "$conf_workdir/$repodir/shlibs" ]; then
			repo_shlibs="$conf_workdir/$repodir/shlibs"
		fi

		if [ -n "$repo_shlibs" ] && [ -f "$repo_shlibs" ]; then
			msg info "Merging shlibs from ${green}${bold}$repo${reset_colour}"

			# Read extra repo shlibs line by line
			while IFS= read -r line; do
				# Skip empty lines
				[ -z "$line" ] && continue
				# Skip comments
				case "$line" in
					\#*) continue ;;
				esac

				# Extract the SONAME (first field) and package (second field)
				soname=$(echo "$line" | awk '{print $1}')
				package=$(echo "$line" | awk '{print $2}')

				# Skip if soname or package is empty
				[ -z "$soname" ] || [ -z "$package" ] && continue

				# Escape special characters for sed
				escaped_line=$(printf '%s\n' "$line" | sed 's/[&/\]/\\&/g')
				# Check if this exact soname+package combination exists
				if grep -q "^$soname $package" "$shlibs_temp"; then
					# Update existing entry (keep original position)
					sed -i "s|^$soname $package.*|$escaped_line|" "$shlibs_temp"
					msg debug "Updated shlib entry: $soname $package"
				elif grep -q "^$soname " "$shlibs_temp"; then
					# Different package for same soname - update it
					sed -i "s|^$soname .*|$escaped_line|" "$shlibs_temp"
					msg debug "Replaced shlib entry: $soname $package"
				else
					# Add new entry at the end
					echo "$line" >> "$shlibs_temp"
					msg debug "Added new shlib entry: $soname $package"
				fi
			done < "$repo_shlibs"
		else
			msg debug "No shlibs file found in $repo"
		fi
	done

	# Write final file (no sorting - preserve order)
	mv "$shlibs_temp" "$shlibs_final"

	msg info "Shlibs merge completed"
}

merge_xtra_templates() {
	# First remove all templates lists
	if [ "$op_log" = 0 ]; then
		rm -f "$conf_workdir"/templates_*
		rm -f "$conf_workdir"/*_templates
	else
		rm -v "$conf_workdir"/templates_* 2>/dev/null
		rm -v "$conf_workdir"/*_templates 2>/dev/null
	fi
	# Merge all available template directories to a temporary directory,
	# With intelligent version-based conflict resolution.
	for repo in $repos_list; do
		have_branch
		find_repodir "$repo"
		if [ "$repo" != "$default_repo" ]; then
			msg info "Merging templates from ${green}${bold}$repo${R}"
			search_path="$conf_workdir/$repodir"
			if [ -d "$conf_workdir/$repodir/srcpkgs" ]; then
				search_path="$conf_workdir/$repodir/srcpkgs"
			fi
			msg debug "Searching in $search_path"

			# Create xtra repo templates list
			repo_name=$(basename "$repo")

			# Use find instead of for loop - much faster
			find "$search_path" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; >> "$conf_workdir/templates_$repo_name"

			# Batch copy all templates at once, then selectively update
			for dir in "$search_path"/*; do
				[ ! -d "$dir" ] && [ ! -L "$dir" ] && continue
				[ ! -e "$dir/template" ] && continue
				processed=$((processed + 1))
				printf "\r%5d " "$processed"
				#printf "\r%5d/%5d " "$processed" "$total"
				template_name=$(basename "$dir")
				source_template="$dir/template"
				dest_template="$conf_workdir/$default_repo_dir/srcpkgs/$template_name/template"

				if should_copy_template "$source_template" "$dest_template"; then
					# Remove from merged_dir if it already exists
					[ -d "$merged_dir/$template_name" ] && rm -rf "$merged_dir/$template_name"
					cp -r "$dir" "$merged_dir" || msg error "Cannot merge templates"
				fi
			done
			printf "\n"
		else
			# Use find for void_templates too - much faster than loop
			find "$conf_workdir/$default_repo_dir/srcpkgs" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; > "$conf_workdir"/void_templates
		fi
	done
	# Create template list for restricted packages, in order to include them in update discovery and updates.
	grep -lr "restricted=yes" "$conf_workdir/$default_repo_dir/srcpkgs/" |  awk -F '/' '{print $(NF-1)}' > "$conf_workdir/templates_restricted-packages"
}

integrate_xtra_templates() {
	# Early return if integration is not needed
	if [ "$op_integrate" = 0 ]; then
		msg debug "Integration not needed"
		return 0
	fi
	# Copy merged directory contents to the srcpkgs/ of the void-packages clone.
	if [ "$op_log" = 0 ]; then
		merge_xtra_templates 2>&1 &
		merge_pid=$!
		show_progress $merge_pid
		wait $merge_pid || msg error "Template merge failed"
		# Merge shlibs
		merge_shlibs 2>&1 &
		shlibs_pid=$!
		show_progress $shlibs_pid
		wait $shlibs_pid || msg error "Shlibs merge failed"
	else
		merge_xtra_templates
		merge_shlibs
	fi

	# Check if merged_dir has any content
	if [ -n "$(ls -A "$merged_dir" 2>/dev/null)" ]; then
		# Remove original directories from void-packages to avoid stale patches
		msg debug "Cleaning older package directories from void-packages"
		for merged_pkg in "$merged_dir"/*; do
			pkg_name=$(basename "$merged_pkg")
			original_pkg="$conf_workdir/$default_repo_dir/srcpkgs/$pkg_name"
			if [ -d "$original_pkg" ]; then
				msg debug "Removing old package directory: $pkg_name"
				rm -rf "$original_pkg" || msg error "Cannot remove $original_pkg"
			fi
		done
		cp -r "$merged_dir"/* "$conf_workdir/$default_repo_dir/srcpkgs/" || msg error "Cannot copy templates to srcpkgs"
		msg info "Merged templates copied to srcpkgs"
	else
		msg info "No new or updated templates to merge"
	fi

	# Update template list if needed
	if [ "$op_changed" = 1 ]; then
		update_template_list

		# Commit template list changes
		if git diff --quiet HEAD; then
			msg debug "No template list changes to commit"
		else
			git add -A || msg error "Cannot stage template list changes"
			git commit -m "update template list" || msg error "Cannot commit template list"
			msg info "Template list updated and committed"
		fi
	fi

	return 0
}

xbps_src_command() {
	# Give xbps-src commands directly to the merged repository.
	cd "$conf_workdir"/"$default_repo_dir" || msg error "Cannot change directory into $default_repo_dir"
	./xbps-src clean || msg error "Cannot execute <xbps-src clean>."
	./xbps-src "$op_xbps_src" || msg error "Cannot execute <xbps-src $op_xbps_src>"
	msg info "[./xbps-src $op_xbps_src] executed successfully!" && exit 0
}

search_templates() {
	# Search available templates.
	if [ "$op_query" = 0 ]; then
		msg debug "No template search requested.."
		return
	fi

	# Update template_list if not exist
	if [ ! -f "$conf_workdir"/all_templates ]; then
		update_template_list
	fi

	msg info "Searching for <$template_query> ..."
	found=0
	for file in "$conf_workdir"/templates_* "$conf_workdir"/void_templates; do
		[ ! -f "$file" ] && continue
		if grep -q "$template_query" "$file"; then
			found=1
			file_name=$(basename "$file")
			case "$file_name" in
				templates_*) file_name=$(echo "$file_name" | cut -d'_' -f2) ;;
				void_templates) file_name="void-packages" ;;
			esac
			msg info "Found in ${green}${bold}$file_name${R}:"
			grep "$template_query" "$file" | while read -r line; do
				printf "%s\n" "  ${green}(*)${R} ${bold}${line}${R}"
			done
		fi
	done
	if [ "$found" = 0 ]; then
		msg warn "No templates found!"
	fi
	exit 0
}

discover_updates() {
	# Compare versions of available templates to these of installed
	# packages and create a list of packages to update.
	msg info "Checking for updatable packages..."
	for template in $xtra_templates; do
		msg debug "Checking $template"
		if xbps-query -p pkgname "$template" >/dev/null; then
			templates_to_check="$templates_to_check $template"
		fi
	done
	for template in $templates_to_check; do
		msg debug "Comparing versions of $template"
		get_version "$merged_dir/$template"/template
		get_revision "$merged_dir/$template"/template
		template_version=$(echo "$version"_"$revision" | sed 's/\.//g')
		installed_version=$(xbps-query -p pkgver "$template" | sed "s/$template-//g" | sed 's/\.//g')
		if [ "$installed_version" -lt "$template_version" ]; then
			templates_to_update="$templates_to_update $template"
		fi
	done
}

update_packages() {
	# Build and install available updates.
	if [ "$op_update" = 1 ]; then
		discover_updates
		if [ -n "$templates_to_update" ]; then
			msg info "Updating $templates_to_update ..."
		else
			msg warn "No updates available"
			exit 0
		fi
		op_install=1
		packages="$templates_to_update"
		install_packages
	fi
}

build_packages() {
	# Prepare for installation

	# Enable building restricted packages
	if grep -q "XBPS_ALLOW_RESTRICTED=yes" "$conf_workdir"/"$default_repo_dir"/etc/conf; then
		msg debug "Building restricted packages is enabled!"
	else
		msg info "Enable building restricted packages!"
		printf "%s" "XBPS_ALLOW_RESTRICTED=yes" "\n" >>"$conf_workdir"/"$default_repo_dir"/etc/conf
	fi

	# Bootstrap if masterdir is not populated
	if [ ! -e "$conf_workdir"/"$default_repo_dir"/masterdir-"$(xbps-uhelper arch)"/usr/bin/xbps-install ]; then
		cd "$conf_workdir"/"$default_repo_dir" || msg error "Cannot change to $conf_workdir"/"$default_repo_dir"
		./xbps-src binary-bootstrap || msg error "Cannot bootstrap!"
	fi

	# Start package build
	if [ "$op_build" = 1 ] && [ "$op_install" = 1 ]; then
		msg error " -b and -i arguments cannot be used at the same time"
	fi
	package_list="$(echo "$packages" | tr ',' ' ')"
	export package_list="$package_list"
	for argument in s l h b u i; do
		first_arg=$(echo $package_list | awk '{print $1}')
		if [ $argument = "$first_arg" ]; then
			msg error "The *$argument* argument cannot be used in that place, a package name is expected!"
		fi
	done
	for package in $package_list; do
		cd "$conf_workdir"/"$default_repo_dir" && ./xbps-src pkg -E "$package"
		cmd_status=$?
		[ "$cmd_status" != 0 ] && msg error "$package build failed, see above!"
	done

	# Exit program if build_packages() is called by itself.
	if [ -n "$packages" ] && [ "$op_install" = 0 ]; then
		msg info "Successfully build $packages!"
		msg info "Packages are in $conf_workdir/$default_repo_dir/hostdir/.
You can install them with xbps or by running <xut -i>."
		exit 0
	fi
}

install_packages() {
	build_packages
	#shellcheck disable=SC2086
	if [ -n "$packages" ] && xi $package_list; then
		msg info " Package(s) $packages installed."
	fi
}

main() {
	# Check for root
	[ "$(id -u)" = 0 ] && msg error "Please run the program as a user!"
	msg info "Full command given is [${green}xut $showargs${R}]."
	[ -n "$op_xbps_src" ] && xbps_src_command
	include_additional_repos

	# Clone repos if needed
	retrieve_repos
	sync_repos
	integrate_xtra_templates
	update_packages
	search_templates
	install_packages
}

# Keep only 5 log files, including the current one.
find "$conf_log_dir" -name "xut_*.log" -print | tail -n+5 | xargs rm -f

while getopts "slhub:i:x:q:" OPTION; do
	case "${OPTION}" in
		s) op_retrieve=1 ;;
		l) op_log=1 ;;
		b) packages="$OPTARG" && op_build=1 ;;
		i) packages="$OPTARG" && op_install=1 ;;
		x) op_xbps_src="$OPTARG" ;;
		q) template_query="$OPTARG" && op_query=1 ;;
		u) op_update=1 ;;
		h|*) usage; exit 0 ;;
	esac
done

# Capture all the arguments given
showargs="$(printf "%s" "$*")"
shift $((OPTIND - 1))
[ "$OPTIND" = 1 ] && usage && exit
if [ "$op_log" = 1 ]; then
	main "$@" 2>&1 | tee -- "$log_file"
else
	main "$@"
fi
