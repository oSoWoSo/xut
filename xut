#!/usr/bin/env sh
## Copyright (c) 2024-2025 by mobinmob  <mobinmob@disroot.org
## This program is free software: you can redistribute it and/or modify it under
## the terms of the GNU General Public License as published by the Free
## Software Foundation, version 2.0 of the License.
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
## You should have received a copy of the GNU General Public License along with
## this program. If not, see <https://www.gnu.org/licenses/>.
### SPDX short identifier: GPL-2.0-only

# For debug uncomment desired set
#set -u # End if are here unused variables
#set -e # End on first error
#set -x # Show what script is going to do

msg() {
	# Use colour-coded messages for informational, warning, and error output ${1} is the message type,
	# ${2} is the message content needs to be here, all messages depend on it.

	# Colours
	green=$(tput setaf 2)
	red=$(tput setaf 1)
	yellow=$(tput setaf 3)
	fade=$(tput dim)
	bold=$(tput bold)
	reset_colour=$(tput sgr0)

	if [ "${1}" = "error" ]; then
		printf "%s\n" "${red}${bold}(!!) Error:${reset_colour} ${bold}${2}${reset_colour}" && exit 1
	elif [ "${1}" = "warn" ]; then
		printf "%s\n" "${yellow}${bold}(~~) Warning:${reset_colour} ${bold}${2} ${reset_colour}"
	elif [ "${1}" = "info" ]; then
		printf "%s\n" "${green}${bold}(~>) Info:${reset_colour}  ${bold}${2} ${reset_colour}"
	elif [ "${1}" = "debug" ]; then
		[ "$op_log" -eq 1 ] && printf "%s\n" "$fade(<>) Debug : ${2} ${reset_colour}"
	else
		printf "%s\n" "${red}(!!) Error: ${1} is not recognised for msg() ${reset_colour}" && exit 1
	fi
}

# Get the configuration from the conf file if it exists.

#shellcheck disable=SC1091
if [ -e "$HOME"/xutconf ]; then
	. "$HOME"/xutconf
	msg info "Using configuration from $HOME/xutconf."
elif [ -e "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf ]; then
	. "${XDG_CONFIG_HOME:-$HOME/.config}"/xutconf
	msg info "Using configuration from ${XDG_CONFIG_HOME:-$HOME/.config}/xutconf."
else
	msg info "Using the default configuration."
fi

# Setting default configuration

readonly default_repo=https://github.com/void-linux/void-packages
readonly repo_abyss_packages=https://codeberg.org/mobinmob/abyss-packages
default_repo_dir=$(printf '%s' "$default_repo" | awk -F"/" '{ print "/"$(NF-1)"/"$NF }' | tr "/" "_")
readonly default_repo_dir
[ -z "$conf_workdir" ] && conf_workdir="$HOME"/.xut

# Define a log filename
conf_log_dir="$conf_workdir/logs"
log_file="$conf_log_dir/$(basename "$0")_$(date +"%Y%m%d_%T")".log

# Check for needed dirs.
[ ! -e "$conf_log_dir" ] && mkdir -p "$conf_log_dir"
readonly log_file
merged_dir=$(mktemp -d)

# Set default operation variables
op_log=0
op_query=0
op_build=0
op_install=0
op_xbps_src=""
op_update=0
op_changed=0

usage() {
	# Display basic tui information
	cat <<-EOH
		Usage: $(basename "$0") [options]

		*x*tra *u*ser *t*emplates
		Build and install packages for Void Linux, from the abyss-packages unofficial repo

		OPTIONS
		 -s                      Sync the repos.
		 -l                      Keep a log file under $conf_log_dir.
		 -h                      Display this usage information.
		 -b <package1,package2>  Build a list of (comma-separated) packages.
		 -i <package1,package2>  Build and install a list of (comma-seperated) packages.
		 -x                      Give xbps-src commands.
		 -q <query>              Search for <query> in available templates.
		 -u                      Update packages.

	 The options are given together. For example in order to sync,
	 enable logging and install <package> the cli command is
	 <xut -sli package>.

	EOH
}

find_repodir() {
	# Define a proper (no slashes...) directory name for a remote git repo
	repodir=$(printf '%s' "${1}" | awk -F"/" '{ print "/"$(NF-1)"/"$NF }' | tr "/" "_")
}

get_version() {
	# Get the version from the template file given as ${1}
	template_file="$1"
	version=$(grep -E "^(version)[=]" "$template_file" | \
			  sed -E 's/^(version)[=][[:space:]]*["]?([0-9.]+)["]?.*/\2/')
	echo "$version"
}

get_revision() {
	# Get the revision from the template file given as ${1}
	template_file="$1"
	revision=$(grep -E "^(revision)[=]" "$template_file" | \
			   sed -E 's/^(revision)[=][[:space:]]*["]?([0-9]+)["]?.*/\2/')
	echo "$revision"
}


include_additional_repos() {
	# Add all repos to a list, repo_abyss_package is last and its contents superseed the others.
	repos_list="$default_repo"
	#shellcheck disable=SC2154
	for xtra_repo in $additional_repos; do
		repos_list="$repos_list $xtra_repo"
	done
	repos_list="$repos_list $repo_abyss_packages"
}

retrieve_repos() {
	# Clone every configured repo if needed.
	msg info "Cloning repos..."
	for repo in $repos_list; do
		find_repodir "$repo"
		if [ ! -d "$conf_workdir"/"$repodir" ]; then
			op_changed=1
			msg debug "Cloning $repo..."
			git clone --depth 1 "$repo" "$conf_workdir"/"$repodir" || msg error "Cannot clone $repo repo."
			msg debug "Successfully cloned $repo !"
		else
			msg debug "$repo already exists in $repodir !"
		fi
	done

	# Remove all non-upstream repo from the void-packaged clone to start from scratch
	cd "$conf_workdir"/"$default_repo_dir" && git checkout .
}

sync_repos() {
	# Sync every configured repo.
	if [ "$op_sync" = 1 ]; then
		msg info "Syncing repos..."
		for repo in $repos_list; do
			find_repodir "$repo"
			msg debug "Syncing with $repo..."
			cd "$conf_workdir"/"$repodir" || msg error "Cannot change to the $conf_workdir/$repodir ..."
			# Store current commit hash before pull
			before_hash=$(git rev-parse HEAD)
			git pull "$repo" "$(git branch --show-current)" || msg error "Cannot sync to the $repo ..."
			# Check if anything changed after pull
			after_hash=$(git rev-parse HEAD)
			if [ "$before_hash" != "$after_hash" ]; then
				op_changed=1
				msg debug "Changes detected in $repo repo."
			fi
			msg debug "Successfully synced $repo repo."
		done
	else
		msg debug "Not syncing repos..."
	fi
}

merge_xtra_templates() {
	# Merge all available template directories to a temporary directory,
	# later list entries take precedence (override previous).
	for repo in $repos_list; do
		find_repodir "$repo"
		if [ "$repo" != "$default_repo" ]; then
			if [ -d "$conf_workdir"/"$repodir"/srcpkgs ]; then
				# Search in srcpkgs
				for dir in "$conf_workdir"/"$repodir"/srcpkgs/*; do
					if [ -e "$dir"/template ]; then
						#shellcheck disable=SC2086
						cp -r "$dir" "$merged_dir" || msg error "Cannot merge templates from $repo..."
					fi
				done
			else
				for dir in "$conf_workdir"/"$repodir"/*; do
					if [ -e "$dir"/template ]; then
						# shellcheck disable=SC2086
						cp -r "$dir" "$merged_dir" || msg error "Cannot merge templates from $repo... "
					fi
				done
			fi
		fi
	done
	for subdir in "$merged_dir"/*; do
		template_list="$template_list $(basename "$subdir")"
	done
}

integrate_xtra_templates() {
	# Copy merged directory contents to the srcpkgs/ of the void-packages clone.
	merge_xtra_templates
	cp -r "$merged_dir"/* "$conf_workdir/$default_repo_dir/srcpkgs/" || msg error "Cannot copy templates to srcpkgs"
}

update_template_list() {
	msg info "Creating list of templates (This will take a while)"
	for subdir in "$conf_workdir/$default_repo_dir/srcpkgs/"* ; do
		master_template_list="$master_template_list $(basename "$subdir")"
	done
	echo "$master_template_list" > "$conf_workdir"/master_template_list
	msg debug "Template merge completed."
	msg info "Available templates: ${green}${bold}$(cat $conf_workdir/master_template_list | wc -w)${reset_colour}"
}

xbps_src_command() {
	# Give xbps-src commands directly to the merged repository.
	cd "$conf_workdir"/"$default_repo_dir" || msg error "Cannot change directory into $default_repo_dir"
	./xbps-src clean || msg error "Cannot execute <xbps-src clean>."
	./xbps-src "$op_xbps_src" || msg error "Cannot execute <xbps-src $op_xbps_src>"
	msg info "[./xbps-src $op_xbps_src] executed successfully!" && exit 0
}

search_templates() {
	# Search available templates.
	if [ "$op_query" -eq 1 ]; then
		msg info "Searching for <$template_query> ..."
		query_results=$(cat "$conf_workdir"/master_template_list | tr " " "\n" | awk /"$template_query"/)
		if [ -n "$query_results" ]; then
			msg info "Search results :"
			for result in ${query_results}; do
				printf "%s\n"  "${green}(*)${reset_colour} ${bold}${result}${reset_colour}"
			done
		exit 0
		else
			msg warn "No templates found!" && exit 0
		fi
	# The following lets the programm continue if no query is actually needed.
	else
		msg debug "No template search requested.." && return
	fi
}

discover_updates() {
	# Compare versions of available templates to these of installed
	# packages and create a list of packages to update.
	for template in $template_list; do
		if xbps-query -p pkgname "$template" >/dev/null; then
			templates_to_check="$templates_to_check $template"
		fi
	done
	for template in $templates_to_check; do
		version=$(get_version "$merged_dir/$template"/template)
		revision=$(get_revision "$merged_dir/$template"/template)
		template_version=$(echo "$version""$revision" | sed "s/[_.]//g")
		installed_version=$(xbps-query -p pkgver "$template" | sed "s/$template-//g" |  sed "s/[_.]//g" )
		if [ "$installed_version" -lt "$template_version" ]; then
			templates_to_update="$templates_to_update $template"
		fi
	done
}

update_packages() {
	# Build and install available updates.
	if [ "$op_update" = 1 ]; then
		discover_updates
		if [ -n "$templates_to_update" ]; then
			msg info "Updating $templates_to_update ..."
		else
			msg warn "No updates available" && exit 0
		fi
		op_install=1
		packages="$templates_to_update"
		install_packages
	fi
}

build_packages() {
	# Prepare for installation

	# Enable building restricted packages
	if grep -q "XBPS_ALLOW_RESTRICTED=yes" "$conf_workdir"/"$default_repo_dir"/etc/conf; then
		msg debug "Building restricted packages is enabled!"
	else
		msg info "Enable building restricted packages!"
		printf "%s" "XBPS_ALLOW_RESTRICTED=yes" "\n" >>"$conf_workdir"/"$default_repo_dir"/etc/conf
	fi

	# Bootstrap if masterdir is not populated
	if [ ! -e "$conf_workdir"/"$default_repo_dir"/masterdir-"$(xbps-uhelper arch)"/usr/bin/xbps-install ]; then
		cd "$conf_workdir"/"$default_repo_dir" || msg error "Cannot change to $conf_workdir"/"$default_repo_dir"
		./xbps-src binary-bootstrap || msg error "Cannot bootstrap!"
	fi

	# Start package build
	if [ "$op_build" -eq 1 ] && [ "$op_install" -eq 1 ]; then
		msg error " -b and -i arguments cannot be used at the same time"
	fi
	package_list="$(echo "$packages" | tr ',' ' ')"
	export package_list="$package_list"
	for argument in s l h b u i; do
			first_arg=$(echo $package_list | awk '{print $1}')
			if [ $argument = "$first_arg" ]; then
				msg error "The *$argument* argument cannot be used in that place, a package name is expected!"
			fi
	done
	for package in $package_list; do
		cd "$conf_workdir"/"$default_repo_dir" && ./xbps-src pkg -E "$package"
		cmd_status=$?
		[ "$cmd_status" != 0 ] && msg error "$package build failed, see above!"
	done

	# Exit program if build_packages() is called by itself.
	if [ -n "$packages" ] && [ "$op_install" -eq 0 ]; then
		msg info "Successfully build $packages!"
		msg info "Packages are in $conf_workdir/$default_repo_dir/hostdir/.
You can install them with xbps or by running <xut -i>."
		exit 0
	fi
}

install_packages() {
	build_packages
	#shellcheck disable=SC2086
	if [ -n "$packages" ] && xi $package_list; then
		msg info " Package(s) $packages installed."
	fi
}

main() {
	# Check for root
	[ "$(id -u)" -eq 0 ] && msg error "Please run the program as a user!"
	msg info "Full command given is [xut $showargs]."
	[ -n "$op_xbps_src" ] && xbps_src_command
	include_additional_repos

	# Clone repos if needed
	retrieve_repos
	sync_repos
	integrate_xtra_templates
	if [ ! -f "$conf_workdir"/master_template_list ]; then update_template_list && lists_updated=1; fi
	if [ "$op_changed" = 1 ] && [ -z lists_updated ] ; then update_template_list ; fi
	update_packages
	search_templates
	install_packages
}

# Keep only 5 log files, including the current one.
find "$conf_log_dir" -name "xut_*.log" -print | tail -n+5 | xargs rm -f

while getopts "slhub:i:x:q:" OPTION; do
	case "${OPTION}" in
		s) op_sync=1 ;;
		l) op_log=1 ;;
		h)
			usage
			exit 0
			;;
		b) packages="$OPTARG" && op_build=1 ;;
		i) packages="$OPTARG" && op_install=1 ;;
		x) op_xbps_src="$OPTARG" ;;
		q) template_query="$OPTARG" && op_query=1 ;;
		u) op_update=1 ;;
		*)
			usage
			exit 0
			;;
	esac
done

# Capture all the arguments given
showargs="$(printf "%s" "$*")"
shift $((OPTIND - 1))
[ "$OPTIND" -eq 1 ] && usage && exit
if [ "$op_log" = 1 ]; then
	main "$@" 2>&1 | tee -- "$log_file"
else
	main "$@"
fi
